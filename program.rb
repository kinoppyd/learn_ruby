#!/usr/bin/ruby

# Rubyの演算子一覧(解決の優先度順)
# 演算子			意味
# ::				スコープ解決
# []				添字
# +(単項） ! ~			正符号、論理否定(NOT)、ビット反転
# **				べき乗
# -(単項)			負符号
# * / %				乗算、除算、剰余
# + -				加算、減算
# << >>				左ビットシフト/データ出力、右ビットシフト/データ入力
# &				ビット積（AND)
# | ^				ビット和(OR)、排他的ビット和(XOR)
# > >= < <=			大小比較
# <=> == === != =~ !~		比較、同値、case同値、非同値、パターンマッチ、パターン非マッチ
# &&				論理積(AND)
# || 				論理和(OR)
# .. ...			範囲生成
# ? :				条件演算子
# = += -= []= など		代入
# not				論理否定
# and or			論理積、論理和

# 再定義可能な演算子一覧
# | ^ & <=> == === =~ > >= < <= << >>
# + - * / % ** ~ +@ -@ [] []=
# これらの演算子は、記述しやすくするためのシンタックスシュガーであり、実際にはオブジェクトのメソッド呼び出しとして解釈される
# 例： 1+2 という式は 1.+(2) という式のシンタックスシュガー
# なお、+@と-@は単項の+と-を表す
# 例： -(1+2) という式は 1.+(2).-@() のシンタックスシュガー
p 3.*(4)	# => 12
p 1.+(5).-@()	# => -6

# TODO:実際に再定義するコードを、オブジェクトの学習が終わったら記述する

# 自己代入演算子は、再定義不可
# += -= *= /= %= **= <<= >>= |= &= ^= &&= ||=
# ただし、a += b は常に a=a+b の様に解釈されるため、+などの演算子を再定義することで事実上再定義が可能

# 否定演算子 != !~ は、再定義不可（ただし、Ruby1.9以降では可能）
p 1 != 1	# => false
p 1 != 2	# => true

# インクリメント、デクリメント演算子は、Rubyには存在しない
# イテレーションの機能が発達しているため、通常はあまり使用しないというのが理由らしい

# 再定義不可能な演算子（言語仕様として定められた演算子）
# = ?: .. ... | not && and || or ::

# 多重代入
# 複数の式を平行して代入することを、多重代入と呼ぶ
a, b, c = 1, 2, 3 # a=1; b=2; c=3; と記述するのと変わりなしだが、評価順序が異なる
p a	# => 1
p b	# => 2
p c	# => 3
a, b = b, a	# 代入される値は、代入が行われるより先に計算されるため、この記述でaとbを入れ替えられる
p a	# => 2
p b	# => 1
# 左右の項目数が合わない場合、余った項は捨てられ、不足した項はnilが入る
d, e = 4, 5, 6
f, g = 7
p d	# => 4
p e	# => 5
p f	# => 7
p g	# => nil

# 配列展開
# 代入時に、変数名の頭に*を付けることで、余った値を捨てずに配列として代入することができる
a, *b = 1,2,3,4,5
p a	# => 1
p b	# => [2, 3, 4, 5]
# また、*が右辺に出現すると、配列を展開して代入出来る
array = [1, 2, 3]
h, i, j = *array
p h	# => 1
p i	# => 2
p j	# => 3

# 要素への代入
# array[1] = 2 という代入式は、実際にはarray.[]=(1,2) というメソッドのシンタックスシュガー
hoge = [1,2,3]
hoge.[]=(1,4)
p hoge	# => [1,4,3]

# 論理演算子
# 比較演算子たちはtrue、falseの値を返し、論理演算子たちはオペラントを返す（C言語と違う仕様）
# （オペランドとは、評価される対象のもののこと。例えば&&や||はオペレータと呼ばれ、その右辺左辺に入るものがオペランドと呼ばれる）
p !true		# => false
p "hoge" && "boo"	# => "boo"
p 1+1 || false		# => 2 (論理和演算子の場合、左辺が先に解釈され、その値が正であれば右辺は短絡され評価されない）
p 1 and 2 || 3		# => 1 (andとorは、&&と||よりも優先度が低いため、後に解釈される）
p 1 && 2 || 3		# => 2 (上の式のandを&&に変えると、1の評価が優先されるため、左辺が返る。更に左辺は||なので短絡され、2が返る）
# また、論理和・論理積がオペランドを返すことから、初期化の際に用いられることが多い(初期化イディオム）
# このサブルーチンでは、引数が与えられた場合はその値をダンプし、与えられなかった場合は100をダンプする
def initialize_value(arg = nil)
	arg ||= 100
	p arg
end
initialize_value(3)	# => 3
initialize_value(10)	# => 10
initialize_value() 	# => 100

# 範囲演算子
# .. と ... は、オペランドを両端とするRangeオブジェクトを生成する
# 両者の違いは、a..bの場合はbが含まれ、a...bの場合はbが含まれない
range = 10..15
p range		# Range オブジェクトなので、10..15というダンプ結果
range.each do |i|	# Rangeオブジェクトに対するイテレーション
	p i
end
for i in 1..10 # 1から10をカウントアップする
	p i
end
for i in 1...10 # 1から9をカウントアップする
	p i
end

# 条件演算子
# まあつまり、三項演算子のことですな
p true ? "TRUE" : "FALSE"	# => "TRUE"
p var = if true then "TRUE" else "FALSE" end	# 上の式と同値(p if true then "TRUE" else "FALSE" end と書いたらsyntax errorを出した.なぜ？）
p false ? "TRUE" : "FALSE"	# => "FALSE"
p var = if false then "TRUE" else "FALSE" end	# 上の式と同値

